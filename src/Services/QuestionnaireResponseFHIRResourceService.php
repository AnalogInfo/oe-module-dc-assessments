<?php

/**
 * FHIR Resource Service class example for implementing the methods that are typically used with FHIR resources via the
 * api.
 *
 * @package   OpenEMR
 * @link      http://www.open-emr.org
 *
 * @author    Stephen Nielson <stephen@nielson.org>
 * @copyright Copyright (c) 2022 Stephen Nielson <stephen@nielson.org>
 * @license   https://github.com/openemr/openemr/blob/master/LICENSE GNU General Public License 3
 */

namespace OpenEMR\Modules\DiscoverAndChange\Assessments\Services;

use OpenEMR\Common\Logging\SystemLogger;
use OpenEMR\Common\Uuid\UuidRegistry;
use OpenEMR\FHIR\Config\ServerConfig;
use OpenEMR\FHIR\R4\FHIRDomainResource\FHIRProvenance;
use OpenEMR\FHIR\R4\FHIRDomainResource\FHIRQuestionnaire;
use OpenEMR\FHIR\R4\FHIRDomainResource\FHIRQuestionnaireResponse;
use OpenEMR\FHIR\R4\FHIRElement\FHIRId;
use OpenEMR\FHIR\R4\FHIRElement\FHIRMeta;
use OpenEMR\FHIR\R4\FHIRResource\FHIRDomainResource;
use OpenEMR\Modules\DiscoverAndChange\Assessments\Services\FhirServices\AssessmentResponseBlobFHIRResourceService;
use OpenEMR\Modules\DiscoverAndChange\Assessments\Services\FhirServices\QuestionnaireResponseFormFHIRResourceService;
use OpenEMR\Modules\DiscoverAndChange\Assessments\Utils\RestUtils;
use OpenEMR\Services\EncounterService;
use OpenEMR\Services\FHIR\FhirProvenanceService;
use OpenEMR\Services\FHIR\FhirServiceBase;
use OpenEMR\Services\FHIR\IResourceCreatableService;
use OpenEMR\Services\FHIR\IResourceReadableService;
use OpenEMR\Services\FHIR\IResourceSearchableService;
use OpenEMR\Services\FHIR\Traits\FhirServiceBaseEmptyTrait;
use OpenEMR\Services\FHIR\Traits\MappedServiceTrait;
use OpenEMR\Services\FHIR\Traits\PatientSearchTrait;
use OpenEMR\Services\FHIR\UtilsService;
use OpenEMR\Services\PatientService;
use OpenEMR\Services\QuestionnaireResponseService;
use OpenEMR\Services\QuestionnaireService;
use OpenEMR\Services\Search\FhirSearchParameterDefinition;
use OpenEMR\Services\Search\SearchFieldType;
use OpenEMR\Services\Search\ServiceField;
use OpenEMR\Services\Search\TokenSearchField;
use OpenEMR\Validators\ProcessingResult;
use Symfony\Component\EventDispatcher\EventDispatcher;
use Symfony\Component\EventDispatcher\GenericEvent;

class QuestionnaireResponseFHIRResourceService extends FhirServiceBase implements IResourceReadableService, IResourceSearchableService, IResourceCreatableService
{
    /**
     * If you'd prefer to keep out the empty methods that are doing nothing uncomment the following helper trait
     */
    use FhirServiceBaseEmptyTrait;
    use PatientSearchTrait;
    use MappedServiceTrait;

    /**
     * @var QuestionnaireResponseService
     */
    private $service;

    private $dispatcher;


    public function __construct(EventDispatcher $dispatcher, $fhirApiURL = null)
    {
        parent::__construct($fhirApiURL);
        $this->dispatcher = $dispatcher;

        // still debating on whether the other mapped services in this module will go here or not, it creates issues
        // when we want to decouple this resource from the module.
        $this->addMappedService(new QuestionnaireResponseFormFHIRResourceService());
    }

    public function insert(FHIRDomainResource $fhirResource): ProcessingResult
    {
        if ($fhirResource->get_fhirElementName() != 'QuestionnaireResponse') {
            throw new \InvalidArgumentException("Invalid resource type for this repository");
        }

        // TODO: @adunsulag if we bring this into core we need to refactor out the generic event
        // TODO: @adunsulag we originally had events then needed to switch to the mapped service for searching, do we drop the event?
        $event = $this->dispatcher->dispatch(new GenericEvent($fhirResource), 'fhir.questionnaire_response.pre_insert');
        if ($event instanceof GenericEvent && $event->isPropagationStopped()) {
            $result = $event->getArgument('result');
            return $result;
        } else {
            return parent::insert($fhirResource); // TODO: Change the autogenerated stub
        }
    }

    public function getAll($fhirSearchParameters, $puuidBind = null): ProcessingResult
    {
        $result = new ProcessingResult();
        $event = $this->dispatcher->dispatch(new GenericEvent($fhirSearchParameters), 'fhir.questionnaire_response.search');
        if ($event instanceof GenericEvent) {
            $result = $event->getArgument('result');
            if ($result instanceof ProcessingResult) {
                if ($event->isPropagationStopped() || !$result->isValid()) {
                    return $result;
                }
            } else {
                $result->setInternalErrors(xlt("The event should have returned a ProcessingResult object"));
            }
        }
        if ($result->isValid()) {
            $processingResult = $this->searchAllServicesWithSupportedFields($fhirSearchParameters, $puuidBind);
            $result->addProcessingResult($processingResult);
        }
        return $result;
    }

    /**
     * This method returns the FHIR search definition objects that are used to map FHIR search fields to OpenEMR fields.
     * Since the mapping can be one FHIR search object to many OpenEMR fields, we use the search definition objects.
     * Search fields can be combined as Composite fields and represent a host of search options.
     * @see https://www.hl7.org/fhir/search.html to see the types of search operations, and search types that are available
     * for use.
     * @return array
     */
    protected function loadSearchParameters()
    {
        return  [
            '_id' => new FhirSearchParameterDefinition(
                '_id',
                SearchFieldType::TOKEN,
                [new ServiceField('questionnaire_response_uuid', ServiceField::TYPE_UUID)]
            )
            ,'questionnaire' => new FhirSearchParameterDefinition(
                'questionnaire',
                SearchFieldType::REFERENCE,
                [new ServiceField('questionnaire_uuid', ServiceField::TYPE_UUID)]
            )
            ,'patient' => $this->getPatientContextSearchField()
            ,'authored' => new FhirSearchParameterDefinition(
                'authored',
                SearchFieldType::DATETIME,
                [new ServiceField('create_time', ServiceField::TYPE_STRING)]
            )
        ];
    }
}
